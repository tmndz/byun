(function () { const e = document.createElement("link").relList; if (e && e.supports && e.supports("modulepreload")) return; for (const i of document.querySelectorAll('link[rel="modulepreload"]')) n(i); new MutationObserver(i => { for (const r of i) if (r.type === "childList") for (const o of r.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && n(o) }).observe(document, { childList: !0, subtree: !0 }); function t(i) { const r = {}; return i.integrity && (r.integrity = i.integrity), i.referrerPolicy && (r.referrerPolicy = i.referrerPolicy), i.crossOrigin === "use-credentials" ? r.credentials = "include" : i.crossOrigin === "anonymous" ? r.credentials = "omit" : r.credentials = "same-origin", r } function n(i) { if (i.ep) return; i.ep = !0; const r = t(i); fetch(i.href, r) } })(); const E = Object.create(null); E.open = "0"; E.close = "1"; E.ping = "2"; E.pong = "3"; E.message = "4"; E.upgrade = "5"; E.noop = "6"; const U = Object.create(null); Object.keys(E).forEach(s => { U[E[s]] = s }); const te = { type: "error", data: "parser error" }, Le = typeof Blob == "function" || typeof Blob < "u" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]", Ie = typeof ArrayBuffer == "function", Ne = s => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(s) : s && s.buffer instanceof ArrayBuffer, le = ({ type: s, data: e }, t, n) => Le && e instanceof Blob ? t ? n(e) : _e(e, n) : Ie && (e instanceof ArrayBuffer || Ne(e)) ? t ? n(e) : _e(new Blob([e]), n) : n(E[s] + (e || "")), _e = (s, e) => { const t = new FileReader; return t.onload = function () { const n = t.result.split(",")[1]; e("b" + (n || "")) }, t.readAsDataURL(s) }; function we(s) { return s instanceof Uint8Array ? s : s instanceof ArrayBuffer ? new Uint8Array(s) : new Uint8Array(s.buffer, s.byteOffset, s.byteLength) } let Q; function Ge(s, e) { if (Le && s.data instanceof Blob) return s.data.arrayBuffer().then(we).then(e); if (Ie && (s.data instanceof ArrayBuffer || Ne(s.data))) return e(we(s.data)); le(s, !1, t => { Q || (Q = new TextEncoder), e(Q.encode(t)) }) } const be = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", C = typeof Uint8Array > "u" ? [] : new Uint8Array(256); for (let s = 0; s < be.length; s++)C[be.charCodeAt(s)] = s; const Ze = s => { let e = s.length * .75, t = s.length, n, i = 0, r, o, c, f; s[s.length - 1] === "=" && (e--, s[s.length - 2] === "=" && e--); const x = new ArrayBuffer(e), m = new Uint8Array(x); for (n = 0; n < t; n += 4)r = C[s.charCodeAt(n)], o = C[s.charCodeAt(n + 1)], c = C[s.charCodeAt(n + 2)], f = C[s.charCodeAt(n + 3)], m[i++] = r << 2 | o >> 4, m[i++] = (o & 15) << 4 | c >> 2, m[i++] = (c & 3) << 6 | f & 63; return x }, et = typeof ArrayBuffer == "function", fe = (s, e) => { if (typeof s != "string") return { type: "message", data: qe(s, e) }; const t = s.charAt(0); return t === "b" ? { type: "message", data: tt(s.substring(1), e) } : U[t] ? s.length > 1 ? { type: U[t], data: s.substring(1) } : { type: U[t] } : te }, tt = (s, e) => { if (et) { const t = Ze(s); return qe(t, e) } else return { base64: !0, data: s } }, qe = (s, e) => e === "blob" ? s instanceof Blob ? s : new Blob([s]) : s instanceof ArrayBuffer ? s : s.buffer, Pe = "", st = (s, e) => { const t = s.length, n = new Array(t); let i = 0; s.forEach((r, o) => { le(r, !1, c => { n[o] = c, ++i === t && e(n.join(Pe)) }) }) }, nt = (s, e) => { const t = s.split(Pe), n = []; for (let i = 0; i < t.length; i++) { const r = fe(t[i], e); if (n.push(r), r.type === "error") break } return n }; function it() { return new TransformStream({ transform(s, e) { Ge(s, t => { const n = t.length; let i; if (n < 126) i = new Uint8Array(1), new DataView(i.buffer).setUint8(0, n); else if (n < 65536) { i = new Uint8Array(3); const r = new DataView(i.buffer); r.setUint8(0, 126), r.setUint16(1, n) } else { i = new Uint8Array(9); const r = new DataView(i.buffer); r.setUint8(0, 127), r.setBigUint64(1, BigInt(n)) } s.data && typeof s.data != "string" && (i[0] |= 128), e.enqueue(i), e.enqueue(t) }) } }) } let j; function P(s) { return s.reduce((e, t) => e + t.length, 0) } function M(s, e) { if (s[0].length === e) return s.shift(); const t = new Uint8Array(e); let n = 0; for (let i = 0; i < e; i++)t[i] = s[0][n++], n === s[0].length && (s.shift(), n = 0); return s.length && n < s[0].length && (s[0] = s[0].slice(n)), t } function rt(s, e) { j || (j = new TextDecoder); const t = []; let n = 0, i = -1, r = !1; return new TransformStream({ transform(o, c) { for (t.push(o); ;) { if (n === 0) { if (P(t) < 1) break; const f = M(t, 1); r = (f[0] & 128) === 128, i = f[0] & 127, i < 126 ? n = 3 : i === 126 ? n = 1 : n = 2 } else if (n === 1) { if (P(t) < 2) break; const f = M(t, 2); i = new DataView(f.buffer, f.byteOffset, f.length).getUint16(0), n = 3 } else if (n === 2) { if (P(t) < 8) break; const f = M(t, 8), x = new DataView(f.buffer, f.byteOffset, f.length), m = x.getUint32(0); if (m > Math.pow(2, 21) - 1) { c.enqueue(te); break } i = m * Math.pow(2, 32) + x.getUint32(4), n = 3 } else { if (P(t) < i) break; const f = M(t, i); c.enqueue(fe(r ? f : j.decode(f), e)), n = 0 } if (i === 0 || i > s) { c.enqueue(te); break } } } }) } const Me = 4; function p(s) { if (s) return ot(s) } function ot(s) { for (var e in p.prototype) s[e] = p.prototype[e]; return s } p.prototype.on = p.prototype.addEventListener = function (s, e) { return this._callbacks = this._callbacks || {}, (this._callbacks["$" + s] = this._callbacks["$" + s] || []).push(e), this }; p.prototype.once = function (s, e) { function t() { this.off(s, t), e.apply(this, arguments) } return t.fn = e, this.on(s, t), this }; p.prototype.off = p.prototype.removeListener = p.prototype.removeAllListeners = p.prototype.removeEventListener = function (s, e) { if (this._callbacks = this._callbacks || {}, arguments.length == 0) return this._callbacks = {}, this; var t = this._callbacks["$" + s]; if (!t) return this; if (arguments.length == 1) return delete this._callbacks["$" + s], this; for (var n, i = 0; i < t.length; i++)if (n = t[i], n === e || n.fn === e) { t.splice(i, 1); break } return t.length === 0 && delete this._callbacks["$" + s], this }; p.prototype.emit = function (s) { this._callbacks = this._callbacks || {}; for (var e = new Array(arguments.length - 1), t = this._callbacks["$" + s], n = 1; n < arguments.length; n++)e[n - 1] = arguments[n]; if (t) { t = t.slice(0); for (var n = 0, i = t.length; n < i; ++n)t[n].apply(this, e) } return this }; p.prototype.emitReserved = p.prototype.emit; p.prototype.listeners = function (s) { return this._callbacks = this._callbacks || {}, this._callbacks["$" + s] || [] }; p.prototype.hasListeners = function (s) { return !!this.listeners(s).length }; const K = typeof Promise == "function" && typeof Promise.resolve == "function" ? e => Promise.resolve().then(e) : (e, t) => t(e, 0), g = typeof self < "u" ? self : typeof window < "u" ? window : Function("return this")(), ct = "arraybuffer"; function De(s, ...e) { return e.reduce((t, n) => (s.hasOwnProperty(n) && (t[n] = s[n]), t), {}) } const at = g.setTimeout, ht = g.clearTimeout; function X(s, e) { e.useNativeTimers ? (s.setTimeoutFn = at.bind(g), s.clearTimeoutFn = ht.bind(g)) : (s.setTimeoutFn = g.setTimeout.bind(g), s.clearTimeoutFn = g.clearTimeout.bind(g)) } const lt = 1.33; function ft(s) { return typeof s == "string" ? ut(s) : Math.ceil((s.byteLength || s.size) * lt) } function ut(s) { let e = 0, t = 0; for (let n = 0, i = s.length; n < i; n++)e = s.charCodeAt(n), e < 128 ? t += 1 : e < 2048 ? t += 2 : e < 55296 || e >= 57344 ? t += 3 : (n++, t += 4); return t } function Fe() { return Date.now().toString(36).substring(3) + Math.random().toString(36).substring(2, 5) } function dt(s) { let e = ""; for (let t in s) s.hasOwnProperty(t) && (e.length && (e += "&"), e += encodeURIComponent(t) + "=" + encodeURIComponent(s[t])); return e } function pt(s) { let e = {}, t = s.split("&"); for (let n = 0, i = t.length; n < i; n++) { let r = t[n].split("="); e[decodeURIComponent(r[0])] = decodeURIComponent(r[1]) } return e } class yt extends Error { constructor(e, t, n) { super(e), this.description = t, this.context = n, this.type = "TransportError" } } class ue extends p { constructor(e) { super(), this.writable = !1, X(this, e), this.opts = e, this.query = e.query, this.socket = e.socket, this.supportsBinary = !e.forceBase64 } onError(e, t, n) { return super.emitReserved("error", new yt(e, t, n)), this } open() { return this.readyState = "opening", this.doOpen(), this } close() { return (this.readyState === "opening" || this.readyState === "open") && (this.doClose(), this.onClose()), this } send(e) { this.readyState === "open" && this.write(e) } onOpen() { this.readyState = "open", this.writable = !0, super.emitReserved("open") } onData(e) { const t = fe(e, this.socket.binaryType); this.onPacket(t) } onPacket(e) { super.emitReserved("packet", e) } onClose(e) { this.readyState = "closed", super.emitReserved("close", e) } pause(e) { } createUri(e, t = {}) { return e + "://" + this._hostname() + this._port() + this.opts.path + this._query(t) } _hostname() { const e = this.opts.hostname; return e.indexOf(":") === -1 ? e : "[" + e + "]" } _port() { return this.opts.port && (this.opts.secure && Number(this.opts.port) !== 443 || !this.opts.secure && Number(this.opts.port) !== 80) ? ":" + this.opts.port : "" } _query(e) { const t = dt(e); return t.length ? "?" + t : "" } } class mt extends ue { constructor() { super(...arguments), this._polling = !1 } get name() { return "polling" } doOpen() { this._poll() } pause(e) { this.readyState = "pausing"; const t = () => { this.readyState = "paused", e() }; if (this._polling || !this.writable) { let n = 0; this._polling && (n++, this.once("pollComplete", function () { --n || t() })), this.writable || (n++, this.once("drain", function () { --n || t() })) } else t() } _poll() { this._polling = !0, this.doPoll(), this.emitReserved("poll") } onData(e) { const t = n => { if (this.readyState === "opening" && n.type === "open" && this.onOpen(), n.type === "close") return this.onClose({ description: "transport closed by the server" }), !1; this.onPacket(n) }; nt(e, this.socket.binaryType).forEach(t), this.readyState !== "closed" && (this._polling = !1, this.emitReserved("pollComplete"), this.readyState === "open" && this._poll()) } doClose() { const e = () => { this.write([{ type: "close" }]) }; this.readyState === "open" ? e() : this.once("open", e) } write(e) { this.writable = !1, st(e, t => { this.doWrite(t, () => { this.writable = !0, this.emitReserved("drain") }) }) } uri() { const e = this.opts.secure ? "https" : "http", t = this.query || {}; return this.opts.timestampRequests !== !1 && (t[this.opts.timestampParam] = Fe()), !this.supportsBinary && !t.sid && (t.b64 = 1), this.createUri(e, t) } } let Ue = !1; try { Ue = typeof XMLHttpRequest < "u" && "withCredentials" in new XMLHttpRequest } catch { } const gt = Ue; function _t() { } class wt extends mt { constructor(e) { if (super(e), typeof location < "u") { const t = location.protocol === "https:"; let n = location.port; n || (n = t ? "443" : "80"), this.xd = typeof location < "u" && e.hostname !== location.hostname || n !== e.port } } doWrite(e, t) { const n = this.request({ method: "POST", data: e }); n.on("success", t), n.on("error", (i, r) => { this.onError("xhr post error", i, r) }) } doPoll() { const e = this.request(); e.on("data", this.onData.bind(this)), e.on("error", (t, n) => { this.onError("xhr poll error", t, n) }), this.pollXhr = e } } class b extends p { constructor(e, t, n) { super(), this.createRequest = e, X(this, n), this._opts = n, this._method = n.method || "GET", this._uri = t, this._data = n.data !== void 0 ? n.data : null, this._create() } _create() { var e; const t = De(this._opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref"); t.xdomain = !!this._opts.xd; const n = this._xhr = this.createRequest(t); try { n.open(this._method, this._uri, !0); try { if (this._opts.extraHeaders) { n.setDisableHeaderCheck && n.setDisableHeaderCheck(!0); for (let i in this._opts.extraHeaders) this._opts.extraHeaders.hasOwnProperty(i) && n.setRequestHeader(i, this._opts.extraHeaders[i]) } } catch { } if (this._method === "POST") try { n.setRequestHeader("Content-type", "text/plain;charset=UTF-8") } catch { } try { n.setRequestHeader("Accept", "*/*") } catch { } (e = this._opts.cookieJar) === null || e === void 0 || e.addCookies(n), "withCredentials" in n && (n.withCredentials = this._opts.withCredentials), this._opts.requestTimeout && (n.timeout = this._opts.requestTimeout), n.onreadystatechange = () => { var i; n.readyState === 3 && ((i = this._opts.cookieJar) === null || i === void 0 || i.parseCookies(n.getResponseHeader("set-cookie"))), n.readyState === 4 && (n.status === 200 || n.status === 1223 ? this._onLoad() : this.setTimeoutFn(() => { this._onError(typeof n.status == "number" ? n.status : 0) }, 0)) }, n.send(this._data) } catch (i) { this.setTimeoutFn(() => { this._onError(i) }, 0); return } typeof document < "u" && (this._index = b.requestsCount++, b.requests[this._index] = this) } _onError(e) { this.emitReserved("error", e, this._xhr), this._cleanup(!0) } _cleanup(e) { if (!(typeof this._xhr > "u" || this._xhr === null)) { if (this._xhr.onreadystatechange = _t, e) try { this._xhr.abort() } catch { } typeof document < "u" && delete b.requests[this._index], this._xhr = null } } _onLoad() { const e = this._xhr.responseText; e !== null && (this.emitReserved("data", e), this.emitReserved("success"), this._cleanup()) } abort() { this._cleanup() } } b.requestsCount = 0; b.requests = {}; if (typeof document < "u") { if (typeof attachEvent == "function") attachEvent("onunload", Ee); else if (typeof addEventListener == "function") { const s = "onpagehide" in g ? "pagehide" : "unload"; addEventListener(s, Ee, !1) } } function Ee() { for (let s in b.requests) b.requests.hasOwnProperty(s) && b.requests[s].abort() } const bt = (function () { const s = He({ xdomain: !1 }); return s && s.responseType !== null })(); class Et extends wt { constructor(e) { super(e); const t = e && e.forceBase64; this.supportsBinary = bt && !t } request(e = {}) { return Object.assign(e, { xd: this.xd }, this.opts), new b(He, this.uri(), e) } } function He(s) { const e = s.xdomain; try { if (typeof XMLHttpRequest < "u" && (!e || gt)) return new XMLHttpRequest } catch { } if (!e) try { return new g[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP") } catch { } } const ze = typeof navigator < "u" && typeof navigator.product == "string" && navigator.product.toLowerCase() === "reactnative"; class xt extends ue { get name() { return "websocket" } doOpen() { const e = this.uri(), t = this.opts.protocols, n = ze ? {} : De(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity"); this.opts.extraHeaders && (n.headers = this.opts.extraHeaders); try { this.ws = this.createSocket(e, t, n) } catch (i) { return this.emitReserved("error", i) } this.ws.binaryType = this.socket.binaryType, this.addEventListeners() } addEventListeners() { this.ws.onopen = () => { this.opts.autoUnref && this.ws._socket.unref(), this.onOpen() }, this.ws.onclose = e => this.onClose({ description: "websocket connection closed", context: e }), this.ws.onmessage = e => this.onData(e.data), this.ws.onerror = e => this.onError("websocket error", e) } write(e) { this.writable = !1; for (let t = 0; t < e.length; t++) { const n = e[t], i = t === e.length - 1; le(n, this.supportsBinary, r => { try { this.doWrite(n, r) } catch { } i && K(() => { this.writable = !0, this.emitReserved("drain") }, this.setTimeoutFn) }) } } doClose() { typeof this.ws < "u" && (this.ws.onerror = () => { }, this.ws.close(), this.ws = null) } uri() { const e = this.opts.secure ? "wss" : "ws", t = this.query || {}; return this.opts.timestampRequests && (t[this.opts.timestampParam] = Fe()), this.supportsBinary || (t.b64 = 1), this.createUri(e, t) } } const G = g.WebSocket || g.MozWebSocket; class vt extends xt { createSocket(e, t, n) { return ze ? new G(e, t, n) : t ? new G(e, t) : new G(e) } doWrite(e, t) { this.ws.send(t) } } class kt extends ue { get name() { return "webtransport" } doOpen() { try { this._transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]) } catch (e) { return this.emitReserved("error", e) } this._transport.closed.then(() => { this.onClose() }).catch(e => { this.onError("webtransport error", e) }), this._transport.ready.then(() => { this._transport.createBidirectionalStream().then(e => { const t = rt(Number.MAX_SAFE_INTEGER, this.socket.binaryType), n = e.readable.pipeThrough(t).getReader(), i = it(); i.readable.pipeTo(e.writable), this._writer = i.writable.getWriter(); const r = () => { n.read().then(({ done: c, value: f }) => { c || (this.onPacket(f), r()) }).catch(c => { }) }; r(); const o = { type: "open" }; this.query.sid && (o.data = `{"sid":"${this.query.sid}"}`), this._writer.write(o).then(() => this.onOpen()) }) }) } write(e) { this.writable = !1; for (let t = 0; t < e.length; t++) { const n = e[t], i = t === e.length - 1; this._writer.write(n).then(() => { i && K(() => { this.writable = !0, this.emitReserved("drain") }, this.setTimeoutFn) }) } } doClose() { var e; (e = this._transport) === null || e === void 0 || e.close() } } const At = { websocket: vt, webtransport: kt, polling: Et }, Bt = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/, St = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"]; function se(s) { if (s.length > 8e3) throw "URI too long"; const e = s, t = s.indexOf("["), n = s.indexOf("]"); t != -1 && n != -1 && (s = s.substring(0, t) + s.substring(t, n).replace(/:/g, ";") + s.substring(n, s.length)); let i = Bt.exec(s || ""), r = {}, o = 14; for (; o--;)r[St[o]] = i[o] || ""; return t != -1 && n != -1 && (r.source = e, r.host = r.host.substring(1, r.host.length - 1).replace(/;/g, ":"), r.authority = r.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), r.ipv6uri = !0), r.pathNames = Tt(r, r.path), r.queryKey = Rt(r, r.query), r } function Tt(s, e) { const t = /\/{2,9}/g, n = e.replace(t, "/").split("/"); return (e.slice(0, 1) == "/" || e.length === 0) && n.splice(0, 1), e.slice(-1) == "/" && n.splice(n.length - 1, 1), n } function Rt(s, e) { const t = {}; return e.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function (n, i, r) { i && (t[i] = r) }), t } const ne = typeof addEventListener == "function" && typeof removeEventListener == "function", H = []; ne && addEventListener("offline", () => { H.forEach(s => s()) }, !1); class k extends p { constructor(e, t) { if (super(), this.binaryType = ct, this.writeBuffer = [], this._prevBufferLen = 0, this._pingInterval = -1, this._pingTimeout = -1, this._maxPayload = -1, this._pingTimeoutTime = 1 / 0, e && typeof e == "object" && (t = e, e = null), e) { const n = se(e); t.hostname = n.host, t.secure = n.protocol === "https" || n.protocol === "wss", t.port = n.port, n.query && (t.query = n.query) } else t.host && (t.hostname = se(t.host).host); X(this, t), this.secure = t.secure != null ? t.secure : typeof location < "u" && location.protocol === "https:", t.hostname && !t.port && (t.port = this.secure ? "443" : "80"), this.hostname = t.hostname || (typeof location < "u" ? location.hostname : "localhost"), this.port = t.port || (typeof location < "u" && location.port ? location.port : this.secure ? "443" : "80"), this.transports = [], this._transportsByName = {}, t.transports.forEach(n => { const i = n.prototype.name; this.transports.push(i), this._transportsByName[i] = n }), this.opts = Object.assign({ path: "/engine.io", agent: !1, withCredentials: !1, upgrade: !0, timestampParam: "t", rememberUpgrade: !1, addTrailingSlash: !0, rejectUnauthorized: !0, perMessageDeflate: { threshold: 1024 }, transportOptions: {}, closeOnBeforeunload: !1 }, t), this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : ""), typeof this.opts.query == "string" && (this.opts.query = pt(this.opts.query)), ne && (this.opts.closeOnBeforeunload && (this._beforeunloadEventListener = () => { this.transport && (this.transport.removeAllListeners(), this.transport.close()) }, addEventListener("beforeunload", this._beforeunloadEventListener, !1)), this.hostname !== "localhost" && (this._offlineEventListener = () => { this._onClose("transport close", { description: "network connection lost" }) }, H.push(this._offlineEventListener))), this.opts.withCredentials && (this._cookieJar = void 0), this._open() } createTransport(e) { const t = Object.assign({}, this.opts.query); t.EIO = Me, t.transport = e, this.id && (t.sid = this.id); const n = Object.assign({}, this.opts, { query: t, socket: this, hostname: this.hostname, secure: this.secure, port: this.port }, this.opts.transportOptions[e]); return new this._transportsByName[e](n) } _open() { if (this.transports.length === 0) { this.setTimeoutFn(() => { this.emitReserved("error", "No transports available") }, 0); return } const e = this.opts.rememberUpgrade && k.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1 ? "websocket" : this.transports[0]; this.readyState = "opening"; const t = this.createTransport(e); t.open(), this.setTransport(t) } setTransport(e) { this.transport && this.transport.removeAllListeners(), this.transport = e, e.on("drain", this._onDrain.bind(this)).on("packet", this._onPacket.bind(this)).on("error", this._onError.bind(this)).on("close", t => this._onClose("transport close", t)) } onOpen() { this.readyState = "open", k.priorWebsocketSuccess = this.transport.name === "websocket", this.emitReserved("open"), this.flush() } _onPacket(e) { if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") switch (this.emitReserved("packet", e), this.emitReserved("heartbeat"), e.type) { case "open": this.onHandshake(JSON.parse(e.data)); break; case "ping": this._sendPacket("pong"), this.emitReserved("ping"), this.emitReserved("pong"), this._resetPingTimeout(); break; case "error": const t = new Error("server error"); t.code = e.data, this._onError(t); break; case "message": this.emitReserved("data", e.data), this.emitReserved("message", e.data); break } } onHandshake(e) { this.emitReserved("handshake", e), this.id = e.sid, this.transport.query.sid = e.sid, this._pingInterval = e.pingInterval, this._pingTimeout = e.pingTimeout, this._maxPayload = e.maxPayload, this.onOpen(), this.readyState !== "closed" && this._resetPingTimeout() } _resetPingTimeout() { this.clearTimeoutFn(this._pingTimeoutTimer); const e = this._pingInterval + this._pingTimeout; this._pingTimeoutTime = Date.now() + e, this._pingTimeoutTimer = this.setTimeoutFn(() => { this._onClose("ping timeout") }, e), this.opts.autoUnref && this._pingTimeoutTimer.unref() } _onDrain() { this.writeBuffer.splice(0, this._prevBufferLen), this._prevBufferLen = 0, this.writeBuffer.length === 0 ? this.emitReserved("drain") : this.flush() } flush() { if (this.readyState !== "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length) { const e = this._getWritablePackets(); this.transport.send(e), this._prevBufferLen = e.length, this.emitReserved("flush") } } _getWritablePackets() { if (!(this._maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1)) return this.writeBuffer; let t = 1; for (let n = 0; n < this.writeBuffer.length; n++) { const i = this.writeBuffer[n].data; if (i && (t += ft(i)), n > 0 && t > this._maxPayload) return this.writeBuffer.slice(0, n); t += 2 } return this.writeBuffer } _hasPingExpired() { if (!this._pingTimeoutTime) return !0; const e = Date.now() > this._pingTimeoutTime; return e && (this._pingTimeoutTime = 0, K(() => { this._onClose("ping timeout") }, this.setTimeoutFn)), e } write(e, t, n) { return this._sendPacket("message", e, t, n), this } send(e, t, n) { return this._sendPacket("message", e, t, n), this } _sendPacket(e, t, n, i) { if (typeof t == "function" && (i = t, t = void 0), typeof n == "function" && (i = n, n = null), this.readyState === "closing" || this.readyState === "closed") return; n = n || {}, n.compress = n.compress !== !1; const r = { type: e, data: t, options: n }; this.emitReserved("packetCreate", r), this.writeBuffer.push(r), i && this.once("flush", i), this.flush() } close() { const e = () => { this._onClose("forced close"), this.transport.close() }, t = () => { this.off("upgrade", t), this.off("upgradeError", t), e() }, n = () => { this.once("upgrade", t), this.once("upgradeError", t) }; return (this.readyState === "opening" || this.readyState === "open") && (this.readyState = "closing", this.writeBuffer.length ? this.once("drain", () => { this.upgrading ? n() : e() }) : this.upgrading ? n() : e()), this } _onError(e) { if (k.priorWebsocketSuccess = !1, this.opts.tryAllTransports && this.transports.length > 1 && this.readyState === "opening") return this.transports.shift(), this._open(); this.emitReserved("error", e), this._onClose("transport error", e) } _onClose(e, t) { if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") { if (this.clearTimeoutFn(this._pingTimeoutTimer), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), ne && (this._beforeunloadEventListener && removeEventListener("beforeunload", this._beforeunloadEventListener, !1), this._offlineEventListener)) { const n = H.indexOf(this._offlineEventListener); n !== -1 && H.splice(n, 1) } this.readyState = "closed", this.id = null, this.emitReserved("close", e, t), this.writeBuffer = [], this._prevBufferLen = 0 } } } k.protocol = Me; class Ct extends k { constructor() { super(...arguments), this._upgrades = [] } onOpen() { if (super.onOpen(), this.readyState === "open" && this.opts.upgrade) for (let e = 0; e < this._upgrades.length; e++)this._probe(this._upgrades[e]) } _probe(e) { let t = this.createTransport(e), n = !1; k.priorWebsocketSuccess = !1; const i = () => { n || (t.send([{ type: "ping", data: "probe" }]), t.once("packet", v => { if (!n) if (v.type === "pong" && v.data === "probe") { if (this.upgrading = !0, this.emitReserved("upgrading", t), !t) return; k.priorWebsocketSuccess = t.name === "websocket", this.transport.pause(() => { n || this.readyState !== "closed" && (m(), this.setTransport(t), t.send([{ type: "upgrade" }]), this.emitReserved("upgrade", t), t = null, this.upgrading = !1, this.flush()) }) } else { const T = new Error("probe error"); T.transport = t.name, this.emitReserved("upgradeError", T) } })) }; function r() { n || (n = !0, m(), t.close(), t = null) } const o = v => { const T = new Error("probe error: " + v); T.transport = t.name, r(), this.emitReserved("upgradeError", T) }; function c() { o("transport closed") } function f() { o("socket closed") } function x(v) { t && v.name !== t.name && r() } const m = () => { t.removeListener("open", i), t.removeListener("error", o), t.removeListener("close", c), this.off("close", f), this.off("upgrading", x) }; t.once("open", i), t.once("error", o), t.once("close", c), this.once("close", f), this.once("upgrading", x), this._upgrades.indexOf("webtransport") !== -1 && e !== "webtransport" ? this.setTimeoutFn(() => { n || t.open() }, 200) : t.open() } onHandshake(e) { this._upgrades = this._filterUpgrades(e.upgrades), super.onHandshake(e) } _filterUpgrades(e) { const t = []; for (let n = 0; n < e.length; n++)~this.transports.indexOf(e[n]) && t.push(e[n]); return t } } let Ot = class extends Ct { constructor(e, t = {}) { const n = typeof e == "object" ? e : t; (!n.transports || n.transports && typeof n.transports[0] == "string") && (n.transports = (n.transports || ["polling", "websocket", "webtransport"]).map(i => At[i]).filter(i => !!i)), super(e, n) } }; function Lt(s, e = "", t) { let n = s; t = t || typeof location < "u" && location, s == null && (s = t.protocol + "//" + t.host), typeof s == "string" && (s.charAt(0) === "/" && (s.charAt(1) === "/" ? s = t.protocol + s : s = t.host + s), /^(https?|wss?):\/\//.test(s) || (typeof t < "u" ? s = t.protocol + "//" + s : s = "https://" + s), n = se(s)), n.port || (/^(http|ws)$/.test(n.protocol) ? n.port = "80" : /^(http|ws)s$/.test(n.protocol) && (n.port = "443")), n.path = n.path || "/"; const r = n.host.indexOf(":") !== -1 ? "[" + n.host + "]" : n.host; return n.id = n.protocol + "://" + r + ":" + n.port + e, n.href = n.protocol + "://" + r + (t && t.port === n.port ? "" : ":" + n.port), n } const It = typeof ArrayBuffer == "function", Nt = s => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(s) : s.buffer instanceof ArrayBuffer, Ve = Object.prototype.toString, qt = typeof Blob == "function" || typeof Blob < "u" && Ve.call(Blob) === "[object BlobConstructor]", Pt = typeof File == "function" || typeof File < "u" && Ve.call(File) === "[object FileConstructor]"; function de(s) { return It && (s instanceof ArrayBuffer || Nt(s)) || qt && s instanceof Blob || Pt && s instanceof File } function z(s, e) { if (!s || typeof s != "object") return !1; if (Array.isArray(s)) { for (let t = 0, n = s.length; t < n; t++)if (z(s[t])) return !0; return !1 } if (de(s)) return !0; if (s.toJSON && typeof s.toJSON == "function" && arguments.length === 1) return z(s.toJSON(), !0); for (const t in s) if (Object.prototype.hasOwnProperty.call(s, t) && z(s[t])) return !0; return !1 } function Mt(s) { const e = [], t = s.data, n = s; return n.data = ie(t, e), n.attachments = e.length, { packet: n, buffers: e } } function ie(s, e) { if (!s) return s; if (de(s)) { const t = { _placeholder: !0, num: e.length }; return e.push(s), t } else if (Array.isArray(s)) { const t = new Array(s.length); for (let n = 0; n < s.length; n++)t[n] = ie(s[n], e); return t } else if (typeof s == "object" && !(s instanceof Date)) { const t = {}; for (const n in s) Object.prototype.hasOwnProperty.call(s, n) && (t[n] = ie(s[n], e)); return t } return s } function Dt(s, e) { return s.data = re(s.data, e), delete s.attachments, s } function re(s, e) { if (!s) return s; if (s && s._placeholder === !0) { if (typeof s.num == "number" && s.num >= 0 && s.num < e.length) return e[s.num]; throw new Error("illegal attachments") } else if (Array.isArray(s)) for (let t = 0; t < s.length; t++)s[t] = re(s[t], e); else if (typeof s == "object") for (const t in s) Object.prototype.hasOwnProperty.call(s, t) && (s[t] = re(s[t], e)); return s } const Ft = ["connect", "connect_error", "disconnect", "disconnecting", "newListener", "removeListener"]; var a; (function (s) { s[s.CONNECT = 0] = "CONNECT", s[s.DISCONNECT = 1] = "DISCONNECT", s[s.EVENT = 2] = "EVENT", s[s.ACK = 3] = "ACK", s[s.CONNECT_ERROR = 4] = "CONNECT_ERROR", s[s.BINARY_EVENT = 5] = "BINARY_EVENT", s[s.BINARY_ACK = 6] = "BINARY_ACK" })(a || (a = {})); class Ut { constructor(e) { this.replacer = e } encode(e) { return (e.type === a.EVENT || e.type === a.ACK) && z(e) ? this.encodeAsBinary({ type: e.type === a.EVENT ? a.BINARY_EVENT : a.BINARY_ACK, nsp: e.nsp, data: e.data, id: e.id }) : [this.encodeAsString(e)] } encodeAsString(e) { let t = "" + e.type; return (e.type === a.BINARY_EVENT || e.type === a.BINARY_ACK) && (t += e.attachments + "-"), e.nsp && e.nsp !== "/" && (t += e.nsp + ","), e.id != null && (t += e.id), e.data != null && (t += JSON.stringify(e.data, this.replacer)), t } encodeAsBinary(e) { const t = Mt(e), n = this.encodeAsString(t.packet), i = t.buffers; return i.unshift(n), i } } class pe extends p { constructor(e) { super(), this.reviver = e } add(e) { let t; if (typeof e == "string") { if (this.reconstructor) throw new Error("got plaintext data when reconstructing a packet"); t = this.decodeString(e); const n = t.type === a.BINARY_EVENT; n || t.type === a.BINARY_ACK ? (t.type = n ? a.EVENT : a.ACK, this.reconstructor = new Ht(t), t.attachments === 0 && super.emitReserved("decoded", t)) : super.emitReserved("decoded", t) } else if (de(e) || e.base64) if (this.reconstructor) t = this.reconstructor.takeBinaryData(e), t && (this.reconstructor = null, super.emitReserved("decoded", t)); else throw new Error("got binary data when not reconstructing a packet"); else throw new Error("Unknown type: " + e) } decodeString(e) { let t = 0; const n = { type: Number(e.charAt(0)) }; if (a[n.type] === void 0) throw new Error("unknown packet type " + n.type); if (n.type === a.BINARY_EVENT || n.type === a.BINARY_ACK) { const r = t + 1; for (; e.charAt(++t) !== "-" && t != e.length;); const o = e.substring(r, t); if (o != Number(o) || e.charAt(t) !== "-") throw new Error("Illegal attachments"); n.attachments = Number(o) } if (e.charAt(t + 1) === "/") { const r = t + 1; for (; ++t && !(e.charAt(t) === "," || t === e.length);); n.nsp = e.substring(r, t) } else n.nsp = "/"; const i = e.charAt(t + 1); if (i !== "" && Number(i) == i) { const r = t + 1; for (; ++t;) { const o = e.charAt(t); if (o == null || Number(o) != o) { --t; break } if (t === e.length) break } n.id = Number(e.substring(r, t + 1)) } if (e.charAt(++t)) { const r = this.tryParse(e.substr(t)); if (pe.isPayloadValid(n.type, r)) n.data = r; else throw new Error("invalid payload") } return n } tryParse(e) { try { return JSON.parse(e, this.reviver) } catch { return !1 } } static isPayloadValid(e, t) { switch (e) { case a.CONNECT: return xe(t); case a.DISCONNECT: return t === void 0; case a.CONNECT_ERROR: return typeof t == "string" || xe(t); case a.EVENT: case a.BINARY_EVENT: return Array.isArray(t) && (typeof t[0] == "number" || typeof t[0] == "string" && Ft.indexOf(t[0]) === -1); case a.ACK: case a.BINARY_ACK: return Array.isArray(t) } } destroy() { this.reconstructor && (this.reconstructor.finishedReconstruction(), this.reconstructor = null) } } class Ht { constructor(e) { this.packet = e, this.buffers = [], this.reconPack = e } takeBinaryData(e) { if (this.buffers.push(e), this.buffers.length === this.reconPack.attachments) { const t = Dt(this.reconPack, this.buffers); return this.finishedReconstruction(), t } return null } finishedReconstruction() { this.reconPack = null, this.buffers = [] } } function xe(s) { return Object.prototype.toString.call(s) === "[object Object]" } const zt = Object.freeze(Object.defineProperty({ __proto__: null, Decoder: pe, Encoder: Ut, get PacketType() { return a } }, Symbol.toStringTag, { value: "Module" })); function _(s, e, t) { return s.on(e, t), function () { s.off(e, t) } } const Vt = Object.freeze({ connect: 1, connect_error: 1, disconnect: 1, disconnecting: 1, newListener: 1, removeListener: 1 }); class We extends p { constructor(e, t, n) { super(), this.connected = !1, this.recovered = !1, this.receiveBuffer = [], this.sendBuffer = [], this._queue = [], this._queueSeq = 0, this.ids = 0, this.acks = {}, this.flags = {}, this.io = e, this.nsp = t, n && n.auth && (this.auth = n.auth), this._opts = Object.assign({}, n), this.io._autoConnect && this.open() } get disconnected() { return !this.connected } subEvents() { if (this.subs) return; const e = this.io; this.subs = [_(e, "open", this.onopen.bind(this)), _(e, "packet", this.onpacket.bind(this)), _(e, "error", this.onerror.bind(this)), _(e, "close", this.onclose.bind(this))] } get active() { return !!this.subs } connect() { return this.connected ? this : (this.subEvents(), this.io._reconnecting || this.io.open(), this.io._readyState === "open" && this.onopen(), this) } open() { return this.connect() } send(...e) { return e.unshift("message"), this.emit.apply(this, e), this } emit(e, ...t) { var n, i, r; if (Vt.hasOwnProperty(e)) throw new Error('"' + e.toString() + '" is a reserved event name'); if (t.unshift(e), this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) return this._addToQueue(t), this; const o = { type: a.EVENT, data: t }; if (o.options = {}, o.options.compress = this.flags.compress !== !1, typeof t[t.length - 1] == "function") { const m = this.ids++, v = t.pop(); this._registerAckCallback(m, v), o.id = m } const c = (i = (n = this.io.engine) === null || n === void 0 ? void 0 : n.transport) === null || i === void 0 ? void 0 : i.writable, f = this.connected && !(!((r = this.io.engine) === null || r === void 0) && r._hasPingExpired()); return this.flags.volatile && !c || (f ? (this.notifyOutgoingListeners(o), this.packet(o)) : this.sendBuffer.push(o)), this.flags = {}, this } _registerAckCallback(e, t) { var n; const i = (n = this.flags.timeout) !== null && n !== void 0 ? n : this._opts.ackTimeout; if (i === void 0) { this.acks[e] = t; return } const r = this.io.setTimeoutFn(() => { delete this.acks[e]; for (let c = 0; c < this.sendBuffer.length; c++)this.sendBuffer[c].id === e && this.sendBuffer.splice(c, 1); t.call(this, new Error("operation has timed out")) }, i), o = (...c) => { this.io.clearTimeoutFn(r), t.apply(this, c) }; o.withError = !0, this.acks[e] = o } emitWithAck(e, ...t) { return new Promise((n, i) => { const r = (o, c) => o ? i(o) : n(c); r.withError = !0, t.push(r), this.emit(e, ...t) }) } _addToQueue(e) { let t; typeof e[e.length - 1] == "function" && (t = e.pop()); const n = { id: this._queueSeq++, tryCount: 0, pending: !1, args: e, flags: Object.assign({ fromQueue: !0 }, this.flags) }; e.push((i, ...r) => (this._queue[0], i !== null ? n.tryCount > this._opts.retries && (this._queue.shift(), t && t(i)) : (this._queue.shift(), t && t(null, ...r)), n.pending = !1, this._drainQueue())), this._queue.push(n), this._drainQueue() } _drainQueue(e = !1) { if (!this.connected || this._queue.length === 0) return; const t = this._queue[0]; t.pending && !e || (t.pending = !0, t.tryCount++, this.flags = t.flags, this.emit.apply(this, t.args)) } packet(e) { e.nsp = this.nsp, this.io._packet(e) } onopen() { typeof this.auth == "function" ? this.auth(e => { this._sendConnectPacket(e) }) : this._sendConnectPacket(this.auth) } _sendConnectPacket(e) { this.packet({ type: a.CONNECT, data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, e) : e }) } onerror(e) { this.connected || this.emitReserved("connect_error", e) } onclose(e, t) { this.connected = !1, delete this.id, this.emitReserved("disconnect", e, t), this._clearAcks() } _clearAcks() { Object.keys(this.acks).forEach(e => { if (!this.sendBuffer.some(n => String(n.id) === e)) { const n = this.acks[e]; delete this.acks[e], n.withError && n.call(this, new Error("socket has been disconnected")) } }) } onpacket(e) { if (e.nsp === this.nsp) switch (e.type) { case a.CONNECT: e.data && e.data.sid ? this.onconnect(e.data.sid, e.data.pid) : this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)")); break; case a.EVENT: case a.BINARY_EVENT: this.onevent(e); break; case a.ACK: case a.BINARY_ACK: this.onack(e); break; case a.DISCONNECT: this.ondisconnect(); break; case a.CONNECT_ERROR: this.destroy(); const n = new Error(e.data.message); n.data = e.data.data, this.emitReserved("connect_error", n); break } } onevent(e) { const t = e.data || []; e.id != null && t.push(this.ack(e.id)), this.connected ? this.emitEvent(t) : this.receiveBuffer.push(Object.freeze(t)) } emitEvent(e) { if (this._anyListeners && this._anyListeners.length) { const t = this._anyListeners.slice(); for (const n of t) n.apply(this, e) } super.emit.apply(this, e), this._pid && e.length && typeof e[e.length - 1] == "string" && (this._lastOffset = e[e.length - 1]) } ack(e) { const t = this; let n = !1; return function (...i) { n || (n = !0, t.packet({ type: a.ACK, id: e, data: i })) } } onack(e) { const t = this.acks[e.id]; typeof t == "function" && (delete this.acks[e.id], t.withError && e.data.unshift(null), t.apply(this, e.data)) } onconnect(e, t) { this.id = e, this.recovered = t && this._pid === t, this._pid = t, this.connected = !0, this.emitBuffered(), this._drainQueue(!0), this.emitReserved("connect") } emitBuffered() { this.receiveBuffer.forEach(e => this.emitEvent(e)), this.receiveBuffer = [], this.sendBuffer.forEach(e => { this.notifyOutgoingListeners(e), this.packet(e) }), this.sendBuffer = [] } ondisconnect() { this.destroy(), this.onclose("io server disconnect") } destroy() { this.subs && (this.subs.forEach(e => e()), this.subs = void 0), this.io._destroy(this) } disconnect() { return this.connected && this.packet({ type: a.DISCONNECT }), this.destroy(), this.connected && this.onclose("io client disconnect"), this } close() { return this.disconnect() } compress(e) { return this.flags.compress = e, this } get volatile() { return this.flags.volatile = !0, this } timeout(e) { return this.flags.timeout = e, this } onAny(e) { return this._anyListeners = this._anyListeners || [], this._anyListeners.push(e), this } prependAny(e) { return this._anyListeners = this._anyListeners || [], this._anyListeners.unshift(e), this } offAny(e) { if (!this._anyListeners) return this; if (e) { const t = this._anyListeners; for (let n = 0; n < t.length; n++)if (e === t[n]) return t.splice(n, 1), this } else this._anyListeners = []; return this } listenersAny() { return this._anyListeners || [] } onAnyOutgoing(e) { return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.push(e), this } prependAnyOutgoing(e) { return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.unshift(e), this } offAnyOutgoing(e) { if (!this._anyOutgoingListeners) return this; if (e) { const t = this._anyOutgoingListeners; for (let n = 0; n < t.length; n++)if (e === t[n]) return t.splice(n, 1), this } else this._anyOutgoingListeners = []; return this } listenersAnyOutgoing() { return this._anyOutgoingListeners || [] } notifyOutgoingListeners(e) { if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) { const t = this._anyOutgoingListeners.slice(); for (const n of t) n.apply(this, e.data) } } } function S(s) { s = s || {}, this.ms = s.min || 100, this.max = s.max || 1e4, this.factor = s.factor || 2, this.jitter = s.jitter > 0 && s.jitter <= 1 ? s.jitter : 0, this.attempts = 0 } S.prototype.duration = function () { var s = this.ms * Math.pow(this.factor, this.attempts++); if (this.jitter) { var e = Math.random(), t = Math.floor(e * this.jitter * s); s = (Math.floor(e * 10) & 1) == 0 ? s - t : s + t } return Math.min(s, this.max) | 0 }; S.prototype.reset = function () { this.attempts = 0 }; S.prototype.setMin = function (s) { this.ms = s }; S.prototype.setMax = function (s) { this.max = s }; S.prototype.setJitter = function (s) { this.jitter = s }; class oe extends p { constructor(e, t) { var n; super(), this.nsps = {}, this.subs = [], e && typeof e == "object" && (t = e, e = void 0), t = t || {}, t.path = t.path || "/socket.io", this.opts = t, X(this, t), this.reconnection(t.reconnection !== !1), this.reconnectionAttempts(t.reconnectionAttempts || 1 / 0), this.reconnectionDelay(t.reconnectionDelay || 1e3), this.reconnectionDelayMax(t.reconnectionDelayMax || 5e3), this.randomizationFactor((n = t.randomizationFactor) !== null && n !== void 0 ? n : .5), this.backoff = new S({ min: this.reconnectionDelay(), max: this.reconnectionDelayMax(), jitter: this.randomizationFactor() }), this.timeout(t.timeout == null ? 2e4 : t.timeout), this._readyState = "closed", this.uri = e; const i = t.parser || zt; this.encoder = new i.Encoder, this.decoder = new i.Decoder, this._autoConnect = t.autoConnect !== !1, this._autoConnect && this.open() } reconnection(e) { return arguments.length ? (this._reconnection = !!e, e || (this.skipReconnect = !0), this) : this._reconnection } reconnectionAttempts(e) { return e === void 0 ? this._reconnectionAttempts : (this._reconnectionAttempts = e, this) } reconnectionDelay(e) { var t; return e === void 0 ? this._reconnectionDelay : (this._reconnectionDelay = e, (t = this.backoff) === null || t === void 0 || t.setMin(e), this) } randomizationFactor(e) { var t; return e === void 0 ? this._randomizationFactor : (this._randomizationFactor = e, (t = this.backoff) === null || t === void 0 || t.setJitter(e), this) } reconnectionDelayMax(e) { var t; return e === void 0 ? this._reconnectionDelayMax : (this._reconnectionDelayMax = e, (t = this.backoff) === null || t === void 0 || t.setMax(e), this) } timeout(e) { return arguments.length ? (this._timeout = e, this) : this._timeout } maybeReconnectOnOpen() { !this._reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect() } open(e) { if (~this._readyState.indexOf("open")) return this; this.engine = new Ot(this.uri, this.opts); const t = this.engine, n = this; this._readyState = "opening", this.skipReconnect = !1; const i = _(t, "open", function () { n.onopen(), e && e() }), r = c => { this.cleanup(), this._readyState = "closed", this.emitReserved("error", c), e ? e(c) : this.maybeReconnectOnOpen() }, o = _(t, "error", r); if (this._timeout !== !1) { const c = this._timeout, f = this.setTimeoutFn(() => { i(), r(new Error("timeout")), t.close() }, c); this.opts.autoUnref && f.unref(), this.subs.push(() => { this.clearTimeoutFn(f) }) } return this.subs.push(i), this.subs.push(o), this } connect(e) { return this.open(e) } onopen() { this.cleanup(), this._readyState = "open", this.emitReserved("open"); const e = this.engine; this.subs.push(_(e, "ping", this.onping.bind(this)), _(e, "data", this.ondata.bind(this)), _(e, "error", this.onerror.bind(this)), _(e, "close", this.onclose.bind(this)), _(this.decoder, "decoded", this.ondecoded.bind(this))) } onping() { this.emitReserved("ping") } ondata(e) { try { this.decoder.add(e) } catch (t) { this.onclose("parse error", t) } } ondecoded(e) { K(() => { this.emitReserved("packet", e) }, this.setTimeoutFn) } onerror(e) { this.emitReserved("error", e) } socket(e, t) { let n = this.nsps[e]; return n ? this._autoConnect && !n.active && n.connect() : (n = new We(this, e, t), this.nsps[e] = n), n } _destroy(e) { const t = Object.keys(this.nsps); for (const n of t) if (this.nsps[n].active) return; this._close() } _packet(e) { const t = this.encoder.encode(e); for (let n = 0; n < t.length; n++)this.engine.write(t[n], e.options) } cleanup() { this.subs.forEach(e => e()), this.subs.length = 0, this.decoder.destroy() } _close() { this.skipReconnect = !0, this._reconnecting = !1, this.onclose("forced close") } disconnect() { return this._close() } onclose(e, t) { var n; this.cleanup(), (n = this.engine) === null || n === void 0 || n.close(), this.backoff.reset(), this._readyState = "closed", this.emitReserved("close", e, t), this._reconnection && !this.skipReconnect && this.reconnect() } reconnect() { if (this._reconnecting || this.skipReconnect) return this; const e = this; if (this.backoff.attempts >= this._reconnectionAttempts) this.backoff.reset(), this.emitReserved("reconnect_failed"), this._reconnecting = !1; else { const t = this.backoff.duration(); this._reconnecting = !0; const n = this.setTimeoutFn(() => { e.skipReconnect || (this.emitReserved("reconnect_attempt", e.backoff.attempts), !e.skipReconnect && e.open(i => { i ? (e._reconnecting = !1, e.reconnect(), this.emitReserved("reconnect_error", i)) : e.onreconnect() })) }, t); this.opts.autoUnref && n.unref(), this.subs.push(() => { this.clearTimeoutFn(n) }) } } onreconnect() { const e = this.backoff.attempts; this._reconnecting = !1, this.backoff.reset(), this.emitReserved("reconnect", e) } } const R = {}; function V(s, e) { typeof s == "object" && (e = s, s = void 0), e = e || {}; const t = Lt(s, e.path || "/socket.io"), n = t.source, i = t.id, r = t.path, o = R[i] && r in R[i].nsps, c = e.forceNew || e["force new connection"] || e.multiplex === !1 || o; let f; return c ? f = new oe(n, e) : (R[i] || (R[i] = new oe(n, e)), f = R[i]), t.query && !e.query && (e.query = t.queryKey), f.socket(t.path, e) } Object.assign(V, { Manager: oe, Socket: We, io: V, connect: V }); class Wt { constructor(e) { this.canvas = document.getElementById(e), this.ctx = this.canvas.getContext("2d"), this.resize(), window.addEventListener("resize", () => this.resize()) } resize() { this.canvas.width = window.innerWidth, this.canvas.height = window.innerHeight } clear() { this.ctx.fillStyle = "#222", this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height) } drawPlayers(e) { Object.values(e).forEach(t => { let n = t.color; if (t.team === "red" && (n = "#ff0000"), t.team === "blue" && (n = "#0000ff"), this.ctx.beginPath(), this.ctx.arc(t.x, t.y, 15, 0, Math.PI * 2), this.ctx.fillStyle = n, this.ctx.fill(), this.ctx.closePath(), this.ctx.fillStyle = "white", this.ctx.font = "12px Arial", this.ctx.textAlign = "center", this.ctx.fillText(t.playerId.substr(0, 4), t.x, t.y - 20), t.hp !== void 0) { const o = t.hp / (t.maxHp || 100); this.ctx.fillStyle = "#333", this.ctx.fillRect(t.x - 40 / 2, t.y - 35, 40, 4), this.ctx.fillStyle = o > .5 ? "#00ff00" : o > .25 ? "#ffaa00" : "#ff0000", this.ctx.fillRect(t.x - 40 / 2, t.y - 35, 40 * o, 4) } }) } drawSchool() { this.ctx.fillStyle = "#2d4d2d", this.ctx.fillRect(350, 100, 100, 60), this.ctx.strokeStyle = "#8B4513", this.ctx.lineWidth = 4, this.ctx.strokeRect(350, 100, 100, 60), this.ctx.fillStyle = "rgba(255,255,255,0.7)", this.ctx.font = "10px monospace", this.ctx.textAlign = "center", this.ctx.fillText("MATH QUIZ", 400, 135) } drawHouses(e) { Object.values(e).forEach(t => { this.ctx.fillStyle = "#444", t.owner && (this.ctx.fillStyle = "#2a442a"), this.ctx.fillRect(t.x - 40, t.y - 40, 80, 80), this.ctx.strokeStyle = "#666", this.ctx.strokeRect(t.x - 40, t.y - 40, 80, 80), this.ctx.fillStyle = "#aaa", this.ctx.font = "10px Arial", this.ctx.textAlign = "center", t.owner ? this.ctx.fillText(t.owner, t.x, t.y + 50) : this.ctx.fillText("For Sale", t.x, t.y + 50), t.furniture && Array.isArray(t.furniture) && t.furniture.forEach(n => { this.ctx.fillStyle = n.color || "#885522", this.ctx.fillRect(n.x - 10, n.y - 10, 20, 20) }) }) } drawArena() { this.ctx.fillStyle = "#800000", this.ctx.fillRect(100, 100, 120, 80), this.ctx.strokeStyle = "#fff", this.ctx.strokeRect(100, 100, 120, 80), this.ctx.fillStyle = "white", this.ctx.font = "14px Arial", this.ctx.textAlign = "center", this.ctx.fillText("WEAPON STORE", 160, 145), this.ctx.fillStyle = "#333", this.ctx.fillRect(600, 100, 100, 120), this.ctx.fillStyle = "#ff0000", this.ctx.globalAlpha = .6, this.ctx.fillRect(610, 110, 80, 100), this.ctx.globalAlpha = 1, this.ctx.fillStyle = "white", this.ctx.fillText("BATTLE GATE", 650, 90) } drawBattleZone() { this.ctx.fillStyle = "#444", this.ctx.strokeStyle = "#777", this.ctx.lineWidth = 2, this.ctx.fillRect(200, 150, 80, 80), this.ctx.strokeRect(200, 150, 80, 80), this.ctx.fillRect(520, 150, 80, 80), this.ctx.strokeRect(520, 150, 80, 80), this.ctx.fillRect(200, 370, 80, 80), this.ctx.strokeRect(200, 370, 80, 80), this.ctx.fillRect(520, 370, 80, 80), this.ctx.strokeRect(520, 370, 80, 80), this.ctx.fillStyle = "#333", this.ctx.fillRect(260, 260, 80, 80), this.ctx.strokeRect(260, 260, 80, 80), this.ctx.fillRect(460, 260, 80, 80), this.ctx.strokeRect(460, 260, 80, 80), this.ctx.strokeStyle = "#ff0000", this.ctx.lineWidth = 3, this.ctx.strokeRect(0, 0, 800, 600) } drawGame(e, t = {}, n = "plaza") { this.clear(), n === "housing" ? this.drawHouses(t) : n === "school" ? this.drawSchool() : n === "arena" ? this.drawArena() : n === "arena_battle" && this.drawBattleZone(), this.drawPlayers(e) } } const l = V(), ce = new Wt("game-canvas"); let d = {}, w = null; const $t = [{ x: 200, y: 150, width: 80, height: 80 }, { x: 520, y: 150, width: 80, height: 80 }, { x: 200, y: 370, width: 80, height: 80 }, { x: 520, y: 370, width: 80, height: 80 }, { x: 260, y: 260, width: 80, height: 80 }, { x: 460, y: 260, width: 80, height: 80 }]; let ye = !1, N = "", $ = "", J = 0, B = {}, y = "plaza"; const Yt = document.getElementById("login-overlay"), Kt = document.getElementById("ui-layer"), Xt = document.getElementById("auth-error"), h = { w: !1, a: !1, s: !1, d: !1, ArrowUp: !1, ArrowLeft: !1, ArrowDown: !1, ArrowRight: !1 }; l.on("connect", () => { console.log("Connected to server"), w = l.id, ye && N && $ && (console.log("Attempting auto-relogin..."), l.emit("login", { username: N, password: $ })) }); l.on("authError", s => { Xt.textContent = s }); l.on("loginSuccess", s => { ye = !0, N = s.username, w = s.playerId, d[w] = s, J = s.money || 0, s.items && Array.isArray(s.items) && (I.length = 0, I.push(...s.items), console.log("Loaded items:", I)), Yt.style.display = "none", Kt.style.display = "block", console.log("Logged in as", s.username), Xe(), y = s.district }); l.on("updateMoney", s => { J = s, Xe() }); l.on("houseData", s => { B = s }); l.on("houseUpdate", s => { B[s.id] = s }); l.on("currentPlayers", s => { ye && (d = {}, Array.isArray(s) ? s.forEach(e => d[e.playerId] = e) : d = s) }); function me(s) { !s || !s.playerId || (d[s.playerId] ? d[s.playerId] = { ...d[s.playerId], ...s } : d[s.playerId] = s) } l.on("newPlayer", s => { me(s) }); l.on("playerMoved", s => { me(s) }); l.on("playerUpdate", s => { me(s) }); l.on("playerDisconnected", s => { delete d[s] }); l.on("playerChangedDistrict", s => { const e = { ...d }; d = {}, s.forEach(t => { e[t.playerId] ? d[t.playerId] = { ...e[t.playerId], ...t } : d[t.playerId] = t }) }); l.on("chatMessage", s => { Gt(s) }); l.on("playerHit", ({ targetId: s, hp: e, attackerId: t }) => { d[s] && (d[s].hp = e) }); l.on("playerRespawned", () => { console.log("You respawned!") }); const Jt = document.getElementById("login-btn"), Qt = document.getElementById("register-btn"), $e = document.getElementById("username-input"), Ye = document.getElementById("password-input"); Jt.addEventListener("click", () => { const s = $e.value.trim(), e = Ye.value.trim(); s && e && ($ = e, l.emit("login", { username: s, password: e })) }); Qt.addEventListener("click", () => { const s = $e.value.trim(), e = Ye.value.trim(); s && e && ($ = e, l.emit("register", { username: s, password: e })) }); const W = document.getElementById("chat-input"), Z = document.getElementById("chat-messages"), q = document.getElementById("map-modal"), ve = document.getElementById("open-map-btn"), ke = document.getElementById("close-map-btn"), jt = document.querySelectorAll(".map-node"); ve && ve.addEventListener("click", () => { q.style.display = "flex", Object.keys(h).forEach(s => h[s] = !1) }); ke && ke.addEventListener("click", () => { q.style.display = "none" }); jt.forEach(s => { s.addEventListener("click", () => { const e = s.getAttribute("data-target"); e && (l.emit("joinDistrict", e), y = e, q.style.display = "none", document.activeElement.blur()) }) }); W.addEventListener("keydown", s => { if (s.key === "Enter") { const e = W.value.trim(); e && (l.emit("chatMessage", e), W.value = "") } s.stopPropagation() }); function Gt(s) { const e = document.createElement("div"); e.className = "message", e.style.borderLeft = `3px solid ${s.color}`; const t = document.createTextNode(s.text), n = document.createElement("span"); n.className = "message-id", n.textContent = s.id.substr(0, 4), e.appendChild(n), e.appendChild(t), Z.appendChild(e), Z.scrollTop = Z.scrollHeight } const Ke = document.getElementById("shop-modal"), Ae = document.getElementById("shop-items"), Be = document.getElementById("close-shop-btn"); let I = [{ id: "sword", name: "Iron Sword", price: 100, desc: "Melee Damage", range: 50 }, { id: "gun", name: "Blaster", price: 250, desc: "Ranged Damage", range: 400 }]; function Zt() {
    Ke.style.display = "flex", Ae.innerHTML = "", I.forEach(s => {
        const e = document.createElement("div"); e.className = "shop-item", e.innerHTML = `
            <div>
                <strong>${s.name}</strong><br>
                <small>${s.desc}</small>
            </div>
            <div>
                <span>${s.price} Coins</span>
                <button onclick="buyItem('${s.id}')">Buy</button>
            </div>
        `, Ae.appendChild(e)
    })
} window.buyItem = function (s) { l.emit("buyItem", s) }; Be && Be.addEventListener("click", () => { Ke.style.display = "none" }); l.on("itemBought", s => { s.success ? alert("Bought " + s.item.name + "!") : alert("Failed: " + s.message) }); const ge = document.getElementById("battle-modal"), Se = document.getElementById("team-selection"), Te = document.getElementById("enter-battle-btn"), Re = document.getElementById("close-battle-btn"), es = document.querySelectorAll('input[name="mode"]'); function ts() { ge.style.display = "flex" } Re && Re.addEventListener("click", () => { ge.style.display = "none" }); es.forEach(s => { s.addEventListener("change", e => { e.target.value === "team" ? Se.style.display = "block" : Se.style.display = "none" }) }); Te && Te.addEventListener("click", () => { const s = document.querySelector('input[name="mode"]:checked').value, e = s === "team" ? document.querySelector('input[name="team"]:checked').value : null; l.emit("joinBattle", { mode: s, team: e }), ge.style.display = "none" }); const A = document.getElementById("quiz-modal"), ae = document.getElementById("quiz-input"), Ce = document.getElementById("submit-quiz-btn"), Oe = document.getElementById("close-quiz-btn"), ss = document.getElementById("quiz-question"), O = document.getElementById("quiz-feedback"); function ns() { A.style.display = "flex", O.textContent = "", ae.value = ""; const s = Math.floor(Math.random() * 10), e = Math.floor(Math.random() * 10); ss.textContent = `${s} + ${e} = ?`, A.setAttribute("data-q", JSON.stringify({ num1: s, num2: e })), ae.focus() } Ce && Ce.addEventListener("click", () => { const s = ae.value; if (s === "") return; const e = JSON.parse(A.getAttribute("data-q")); l.emit("submitQuizAnswer", { questionId: "local", answer: { num1: e.num1, num2: e.num2, answer: s } }) }); Oe && Oe.addEventListener("click", () => { A.style.display = "none" }); l.on("quizResult", s => { s.success ? (O.textContent = `Correct! +${s.reward} Coins`, O.style.color = "#00ff00", setTimeout(() => { A.style.display = "none" }, 1500)) : (O.textContent = "Incorrect, try again.", O.style.color = "#ff4444") }); function Xe() {
    let s = document.getElementById("stats-display"); s || (s = document.createElement("div"), s.id = "stats-display", document.getElementById("ui-layer").appendChild(s)), s.innerHTML = `
        <div>You: ${N}</div>
        <div>Coins: ${J}</div>
    `} function is() { if (u.style.display = "none", y === "housing") { const s = d[w]; if (!s) return; Object.values(B).forEach(e => { const t = s.x - e.x, n = s.y - e.y; Math.sqrt(t * t + n * n) < 50 && (as(e), h.e && (h.e = !1, cs(e))) }) } if (y === "school") { const s = d[w]; if (!s) return; const e = 400, t = 130; Math.sqrt((s.x - e) ** 2 + (s.y - t) ** 2) < 60 && (u.style.display = "block", u.style.left = e + "px", u.style.top = t - 50 + "px", u.textContent = "[E] Start Math Quiz", h.e && (h.e = !1, ns())) } if (y === "arena") { const s = d[w]; if (!s) return; const e = 160, t = 140; Math.sqrt((s.x - e) ** 2 + (s.y - t) ** 2) < 70 && (u.style.display = "block", u.style.left = e + "px", u.style.top = t - 50 + "px", u.textContent = "[E] Open Weapon Shop", h.e && (h.e = !1, Zt())); const i = 650, r = 160; Math.sqrt((s.x - i) ** 2 + (s.y - r) ** 2) < 80 && (u.style.display = "block", u.style.left = i + "px", u.style.top = r - 50 + "px", u.textContent = "[E] Enter Battle", h.e && (h.e = !1, ts())) } } function rs() { if (y !== "arena_battle") return; const s = d[w]; if (!(!s || !s.equipment) && h.space) { h.space = !1; const e = I.find(n => n.id === s.equipment), t = e ? e.range : 50; Object.values(d).forEach(n => { if (n.playerId === w) return; const i = n.x - s.x, r = n.y - s.y; if (Math.sqrt(i * i + r * r) < t) { if (s.mode === "team" && s.team === n.team) return; l.emit("playerAttack", { targetId: n.playerId }) } }) } } l.on("setDistrict", s => { y = s, console.log("Joined district:", s), Object.keys(h).forEach(e => h[e] = !1), q && (q.style.display = "none") }); let L = !1, he = 0; const Je = [{ type: "crate", color: "#8B4513" }, { type: "table", color: "#DEB887" }, { type: "plant", color: "#228B22" }]; window.addEventListener("keydown", s => { document.activeElement !== W && s.key && (s.key.toLowerCase() === "e" && (h.e || (h.e = !0)), s.key === " " && (h.space = !0), s.key.toLowerCase() === "b" && os(), h.hasOwnProperty(s.key) && (h[s.key] = !0)) }); function os() { L = !L; const s = document.getElementById("editor-toolbar"); s && (s.style.display = L ? "flex" : "none"), L && Qe() } const Y = document.createElement("div"); Y.id = "editor-toolbar"; document.getElementById("ui-layer").appendChild(Y); function Qe() { Y.innerHTML = "", Je.forEach((s, e) => { const t = document.createElement("div"); t.className = `editor-item ${e === he ? "selected" : ""}`, t.style.backgroundColor = s.color, t.onclick = () => { he = e, Qe() }, Y.appendChild(t) }) } ce.canvas.addEventListener("mousedown", s => { if (!L) return; const e = ce.canvas.getBoundingClientRect(), t = s.clientX - e.left, n = s.clientY - e.top; let i = null; if (Object.values(B).forEach(r => { t >= r.x - 40 && t <= r.x + 40 && n >= r.y - 40 && n <= r.y + 40 && (i = r.id) }), i && B[i].owner === N) { const r = Je[he]; l.emit("placeFurniture", { houseId: i, item: { type: r.type, color: r.color, x: t, y: n } }) } }); window.addEventListener("keyup", s => { s.key && (s.key.toLowerCase() === "e" && (h.e = !1), s.key === " " && (h.space = !1), h.hasOwnProperty(s.key) && (h[s.key] = !1)) }); function cs(s) { s.owner ? l.emit("enterHouse", s.id) : J >= s.price ? l.emit("buyHouse", s.id) : alert("Not enough money!") } const u = document.createElement("div"); u.id = "interaction-prompt"; u.style.position = "absolute"; u.style.display = "none"; u.style.background = "rgba(0,0,0,0.8)"; u.style.color = "white"; u.style.padding = "5px 10px"; u.style.borderRadius = "4px"; u.style.transform = "translate(-50%, -100%)"; u.style.zIndex = "100"; document.getElementById("ui-layer").appendChild(u); function as(s) { u.style.display = "block", u.style.left = s.x + "px", u.style.top = s.y - 20 + "px", s.owner ? u.textContent = `[E] Enter ${s.owner}'s House` : u.textContent = `[E] Buy ${s.id} (${s.price} coins)` } function ee(s, e, t = 15) { if (y === "arena_battle") for (const n of $t) { const i = Math.max(n.x, Math.min(s, n.x + n.width)), r = Math.max(n.y, Math.min(e, n.y + n.height)), o = s - i, c = e - r; if (o * o + c * c < t * t) return !0 } return !1 } const D = 5; function hs() { if (!w || !d[w]) return; u.style.display = "none", is(), rs(); let s = !1; const e = d[w]; if (A && A.style.display === "flex") return; let t = e.x, n = e.y; if ((h.w || h.ArrowUp) && (n -= D), (h.s || h.ArrowDown) && (n += D), (h.a || h.ArrowLeft) && (t -= D), (h.d || h.ArrowRight) && (t += D), ee(t, n) ? ee(t, e.y) ? ee(e.x, n) || (e.y = n, s = !0) : (e.x = t, s = !0) : (t !== e.x || n !== e.y) && (e.x = t, e.y = n, s = !0), s) { const r = Date.now(); (!e.lastMoveTime || r - e.lastMoveTime > 30) && (l.emit("playerMovement", { x: e.x, y: e.y }), e.lastMoveTime = r), ls(e) } } const F = { plaza: { left: "housing", right: "arena", top: "school" }, housing: { right: "plaza" }, arena: { left: "plaza" }, school: { bottom: "plaza" } }; function ls(s) { let i = null, r = null; s.x < 0 ? (i = F[y]?.left, r = { x: 750, y: s.y }) : s.x > 800 ? (i = F[y]?.right, r = { x: 50, y: s.y }) : s.y < 0 ? (i = F[y]?.top, r = { x: s.x, y: 550 }) : s.y > 600 && (i = F[y]?.bottom, r = { x: s.x, y: 50 }), i ? (h.w = h.a = h.s = h.d = !1, l.emit("joinDistrict", i, r), y = i, console.log(`Traveling to ${i} at`, r)) : (s.x < 0 && (s.x = 0), s.x > 800 && (s.x = 800), s.y < 0 && (s.y = 0), s.y > 600 && (s.y = 600)) } function je() { try { hs(); const s = y === "housing" ? B : {}; ce.drawGame(d, s, y) } catch (s) { console.error("Game Loop Error:", s) } requestAnimationFrame(je) } je();
